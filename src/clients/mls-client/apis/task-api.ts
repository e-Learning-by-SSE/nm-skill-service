/* tslint:disable */
/* eslint-disable */
/**
 * MLS2 API
 * Central API
 *
 * OpenAPI spec version: 0.7.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse20072 } from '../models';
import { TaskJsonld } from '../models';
import { TaskJsonldTaskItemRead } from '../models';
import { TaskJsonldTaskItemWrite } from '../models';
import { TaskJsonldTaskWrite } from '../models';
import { TaskTaskItemWrite } from '../models';
import { TaskTaskWrite } from '../models';
/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes the Task resource.
         * @summary Removes the Task resource.
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskItem: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTaskItem.');
            }
            const localVarPath = `/mls-api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Task resources.
         * @summary Retrieves the collection of Task resources.
         * @param {number} [page] The collection page number
         * @param {number} [itemsPerPage] The number of items per page
         * @param {boolean} [pagination] Enable or disable pagination
         * @param {number} [id] 
         * @param {Array<number>} [id] 
         * @param {string} [title] 
         * @param {string} [lifecycle] 
         * @param {Array<string>} [lifecycle] 
         * @param {string} [taskSet] 
         * @param {Array<string>} [taskSet] 
         * @param {string} [taskSetTitle] 
         * @param {string} [taskSetOrganization] 
         * @param {Array<string>} [taskSetOrganization] 
         * @param {string} [appTags] 
         * @param {Array<string>} [appTags] 
         * @param {string} [appTagsContext] 
         * @param {Array<string>} [appTagsContext] 
         * @param {string} [appTagsTitle] 
         * @param {Array<string>} [appTagsTitle] 
         * @param {string} [groupTaskTodos] 
         * @param {Array<string>} [groupTaskTodos] 
         * @param {string} [originalTask] 
         * @param {Array<string>} [originalTask] 
         * @param {string} [externalContents] 
         * @param {Array<string>} [externalContents] 
         * @param {string} [externalContentOrganizations] 
         * @param {Array<string>} [externalContentOrganizations] 
         * @param {string} [taskTodosUserOrganizations] 
         * @param {Array<string>} [taskTodosUserOrganizations] 
         * @param {string} [taskTodosTaskTodoInfoStatus] 
         * @param {Array<string>} [taskTodosTaskTodoInfoStatus] 
         * @param {number} [mls1Id] 
         * @param {Array<number>} [mls1Id] 
         * @param {string} [taskStepsConnectedForms] 
         * @param {Array<string>} [taskStepsConnectedForms] 
         * @param {string} [copySource] 
         * @param {Array<string>} [copySource] 
         * @param {string} [externalContentOrganizationCopySource] 
         * @param {Array<string>} [externalContentOrganizationCopySource] 
         * @param {string} [userNameOrFilter] 
         * @param {string} [todoOrFilter] 
         * @param {string} [orFilter] 
         * @param {string} [creatorNameOrFilter] 
         * @param {string} [isNewestVersion] 
         * @param {string} [taskSetForTaskFilter] 
         * @param {string} [tagModeFilter] 
         * @param {string} [taskTodoAssignedGroupFilter] 
         * @param {string} [orderTitle] 
         * @param {string} [orderTaskSetTitle] 
         * @param {string} [orderCreatorUsername] 
         * @param {string} [orderEquipmentMaintenancesLastRun] 
         * @param {boolean} [taskTodosArchived] 
         * @param {boolean} [existsTaskTodos] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskCollection: async (page?: number, itemsPerPage?: number, pagination?: boolean, id?: number, id?: Array<number>, title?: string, lifecycle?: string, lifecycle?: Array<string>, taskSet?: string, taskSet?: Array<string>, taskSetTitle?: string, taskSetOrganization?: string, taskSetOrganization?: Array<string>, appTags?: string, appTags?: Array<string>, appTagsContext?: string, appTagsContext?: Array<string>, appTagsTitle?: string, appTagsTitle?: Array<string>, groupTaskTodos?: string, groupTaskTodos?: Array<string>, originalTask?: string, originalTask?: Array<string>, externalContents?: string, externalContents?: Array<string>, externalContentOrganizations?: string, externalContentOrganizations?: Array<string>, taskTodosUserOrganizations?: string, taskTodosUserOrganizations?: Array<string>, taskTodosTaskTodoInfoStatus?: string, taskTodosTaskTodoInfoStatus?: Array<string>, mls1Id?: number, mls1Id?: Array<number>, taskStepsConnectedForms?: string, taskStepsConnectedForms?: Array<string>, copySource?: string, copySource?: Array<string>, externalContentOrganizationCopySource?: string, externalContentOrganizationCopySource?: Array<string>, userNameOrFilter?: string, todoOrFilter?: string, orFilter?: string, creatorNameOrFilter?: string, isNewestVersion?: string, taskSetForTaskFilter?: string, tagModeFilter?: string, taskTodoAssignedGroupFilter?: string, orderTitle?: string, orderTaskSetTitle?: string, orderCreatorUsername?: string, orderEquipmentMaintenancesLastRun?: string, taskTodosArchived?: boolean, existsTaskTodos?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mls-api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemsPerPage !== undefined) {
                localVarQueryParameter['itemsPerPage'] = itemsPerPage;
            }

            if (pagination !== undefined) {
                localVarQueryParameter['pagination'] = pagination;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (id) {
                localVarQueryParameter['id[]'] = id;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (lifecycle !== undefined) {
                localVarQueryParameter['lifecycle'] = lifecycle;
            }

            if (lifecycle) {
                localVarQueryParameter['lifecycle[]'] = lifecycle;
            }

            if (taskSet !== undefined) {
                localVarQueryParameter['taskSet'] = taskSet;
            }

            if (taskSet) {
                localVarQueryParameter['taskSet[]'] = taskSet;
            }

            if (taskSetTitle !== undefined) {
                localVarQueryParameter['taskSet.title'] = taskSetTitle;
            }

            if (taskSetOrganization !== undefined) {
                localVarQueryParameter['taskSet.organization'] = taskSetOrganization;
            }

            if (taskSetOrganization) {
                localVarQueryParameter['taskSet.organization[]'] = taskSetOrganization;
            }

            if (appTags !== undefined) {
                localVarQueryParameter['appTags'] = appTags;
            }

            if (appTags) {
                localVarQueryParameter['appTags[]'] = appTags;
            }

            if (appTagsContext !== undefined) {
                localVarQueryParameter['appTags.context'] = appTagsContext;
            }

            if (appTagsContext) {
                localVarQueryParameter['appTags.context[]'] = appTagsContext;
            }

            if (appTagsTitle !== undefined) {
                localVarQueryParameter['appTags.title'] = appTagsTitle;
            }

            if (appTagsTitle) {
                localVarQueryParameter['appTags.title[]'] = appTagsTitle;
            }

            if (groupTaskTodos !== undefined) {
                localVarQueryParameter['groupTaskTodos'] = groupTaskTodos;
            }

            if (groupTaskTodos) {
                localVarQueryParameter['groupTaskTodos[]'] = groupTaskTodos;
            }

            if (originalTask !== undefined) {
                localVarQueryParameter['originalTask'] = originalTask;
            }

            if (originalTask) {
                localVarQueryParameter['originalTask[]'] = originalTask;
            }

            if (externalContents !== undefined) {
                localVarQueryParameter['externalContents'] = externalContents;
            }

            if (externalContents) {
                localVarQueryParameter['externalContents[]'] = externalContents;
            }

            if (externalContentOrganizations !== undefined) {
                localVarQueryParameter['externalContentOrganizations'] = externalContentOrganizations;
            }

            if (externalContentOrganizations) {
                localVarQueryParameter['externalContentOrganizations[]'] = externalContentOrganizations;
            }

            if (taskTodosUserOrganizations !== undefined) {
                localVarQueryParameter['taskTodos.user.organizations'] = taskTodosUserOrganizations;
            }

            if (taskTodosUserOrganizations) {
                localVarQueryParameter['taskTodos.user.organizations[]'] = taskTodosUserOrganizations;
            }

            if (taskTodosTaskTodoInfoStatus !== undefined) {
                localVarQueryParameter['taskTodos.taskTodoInfo.status'] = taskTodosTaskTodoInfoStatus;
            }

            if (taskTodosTaskTodoInfoStatus) {
                localVarQueryParameter['taskTodos.taskTodoInfo.status[]'] = taskTodosTaskTodoInfoStatus;
            }

            if (mls1Id !== undefined) {
                localVarQueryParameter['mls1Id'] = mls1Id;
            }

            if (mls1Id) {
                localVarQueryParameter['mls1Id[]'] = mls1Id;
            }

            if (taskStepsConnectedForms !== undefined) {
                localVarQueryParameter['taskSteps.connectedForms'] = taskStepsConnectedForms;
            }

            if (taskStepsConnectedForms) {
                localVarQueryParameter['taskSteps.connectedForms[]'] = taskStepsConnectedForms;
            }

            if (copySource !== undefined) {
                localVarQueryParameter['copySource'] = copySource;
            }

            if (copySource) {
                localVarQueryParameter['copySource[]'] = copySource;
            }

            if (externalContentOrganizationCopySource !== undefined) {
                localVarQueryParameter['externalContentOrganizationCopySource'] = externalContentOrganizationCopySource;
            }

            if (externalContentOrganizationCopySource) {
                localVarQueryParameter['externalContentOrganizationCopySource[]'] = externalContentOrganizationCopySource;
            }

            if (userNameOrFilter !== undefined) {
                localVarQueryParameter['userNameOrFilter'] = userNameOrFilter;
            }

            if (todoOrFilter !== undefined) {
                localVarQueryParameter['todoOrFilter'] = todoOrFilter;
            }

            if (orFilter !== undefined) {
                localVarQueryParameter['orFilter'] = orFilter;
            }

            if (creatorNameOrFilter !== undefined) {
                localVarQueryParameter['creatorNameOrFilter'] = creatorNameOrFilter;
            }

            if (isNewestVersion !== undefined) {
                localVarQueryParameter['isNewestVersion'] = isNewestVersion;
            }

            if (taskSetForTaskFilter !== undefined) {
                localVarQueryParameter['taskSetForTaskFilter'] = taskSetForTaskFilter;
            }

            if (tagModeFilter !== undefined) {
                localVarQueryParameter['tagModeFilter'] = tagModeFilter;
            }

            if (taskTodoAssignedGroupFilter !== undefined) {
                localVarQueryParameter['taskTodoAssignedGroupFilter'] = taskTodoAssignedGroupFilter;
            }

            if (orderTitle !== undefined) {
                localVarQueryParameter['order[title]'] = orderTitle;
            }

            if (orderTaskSetTitle !== undefined) {
                localVarQueryParameter['order[taskSet.title]'] = orderTaskSetTitle;
            }

            if (orderCreatorUsername !== undefined) {
                localVarQueryParameter['order[creator.username]'] = orderCreatorUsername;
            }

            if (orderEquipmentMaintenancesLastRun !== undefined) {
                localVarQueryParameter['order[equipmentMaintenances.lastRun]'] = orderEquipmentMaintenancesLastRun;
            }

            if (taskTodosArchived !== undefined) {
                localVarQueryParameter['taskTodos.archived'] = taskTodosArchived;
            }

            if (existsTaskTodos !== undefined) {
                localVarQueryParameter['exists[taskTodos]'] = existsTaskTodos;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Task resource.
         * @summary Retrieves a Task resource.
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskItem: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTaskItem.');
            }
            const localVarPath = `/mls-api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Task resource.
         * @summary Creates a Task resource.
         * @param {TaskJsonldTaskWrite} body The new Task resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaskCollection: async (body: TaskJsonldTaskWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postTaskCollection.');
            }
            const localVarPath = `/mls-api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Task resource.
         * @summary Creates a Task resource.
         * @param {TaskJsonldTaskWrite} body The new Task resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaskCollection: async (body: TaskJsonldTaskWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postTaskCollection.');
            }
            const localVarPath = `/mls-api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCopyFromExternalContentTaskItem: async (body: TaskJsonldTaskItemWrite, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putCopyFromExternalContentTaskItem.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling putCopyFromExternalContentTaskItem.');
            }
            const localVarPath = `/mls-api/tasks/copy-from-external-content/{id}/{externalContentOrganization}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCopyFromExternalContentTaskItem: async (body: TaskJsonldTaskItemWrite, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putCopyFromExternalContentTaskItem.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling putCopyFromExternalContentTaskItem.');
            }
            const localVarPath = `/mls-api/tasks/copy-from-external-content/{id}/{externalContentOrganization}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCopyTaskItem: async (body: TaskJsonldTaskItemWrite, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putCopyTaskItem.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling putCopyTaskItem.');
            }
            const localVarPath = `/mls-api/tasks/copy/{id}/{taskSet}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCopyTaskItem: async (body: TaskJsonldTaskItemWrite, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putCopyTaskItem.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling putCopyTaskItem.');
            }
            const localVarPath = `/mls-api/tasks/copy/{id}/{taskSet}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGenerateNextVersionTaskItem: async (body: TaskJsonldTaskItemWrite, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putGenerateNextVersionTaskItem.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling putGenerateNextVersionTaskItem.');
            }
            const localVarPath = `/mls-api/tasks/generate-next-version/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGenerateNextVersionTaskItem: async (body: TaskJsonldTaskItemWrite, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putGenerateNextVersionTaskItem.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling putGenerateNextVersionTaskItem.');
            }
            const localVarPath = `/mls-api/tasks/generate-next-version/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskItem: async (body: TaskJsonldTaskItemWrite, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putTaskItem.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling putTaskItem.');
            }
            const localVarPath = `/mls-api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskItem: async (body: TaskJsonldTaskItemWrite, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putTaskItem.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling putTaskItem.');
            }
            const localVarPath = `/mls-api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Removes the Task resource.
         * @summary Removes the Task resource.
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskItem(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).deleteTaskItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the collection of Task resources.
         * @summary Retrieves the collection of Task resources.
         * @param {number} [page] The collection page number
         * @param {number} [itemsPerPage] The number of items per page
         * @param {boolean} [pagination] Enable or disable pagination
         * @param {number} [id] 
         * @param {Array<number>} [id] 
         * @param {string} [title] 
         * @param {string} [lifecycle] 
         * @param {Array<string>} [lifecycle] 
         * @param {string} [taskSet] 
         * @param {Array<string>} [taskSet] 
         * @param {string} [taskSetTitle] 
         * @param {string} [taskSetOrganization] 
         * @param {Array<string>} [taskSetOrganization] 
         * @param {string} [appTags] 
         * @param {Array<string>} [appTags] 
         * @param {string} [appTagsContext] 
         * @param {Array<string>} [appTagsContext] 
         * @param {string} [appTagsTitle] 
         * @param {Array<string>} [appTagsTitle] 
         * @param {string} [groupTaskTodos] 
         * @param {Array<string>} [groupTaskTodos] 
         * @param {string} [originalTask] 
         * @param {Array<string>} [originalTask] 
         * @param {string} [externalContents] 
         * @param {Array<string>} [externalContents] 
         * @param {string} [externalContentOrganizations] 
         * @param {Array<string>} [externalContentOrganizations] 
         * @param {string} [taskTodosUserOrganizations] 
         * @param {Array<string>} [taskTodosUserOrganizations] 
         * @param {string} [taskTodosTaskTodoInfoStatus] 
         * @param {Array<string>} [taskTodosTaskTodoInfoStatus] 
         * @param {number} [mls1Id] 
         * @param {Array<number>} [mls1Id] 
         * @param {string} [taskStepsConnectedForms] 
         * @param {Array<string>} [taskStepsConnectedForms] 
         * @param {string} [copySource] 
         * @param {Array<string>} [copySource] 
         * @param {string} [externalContentOrganizationCopySource] 
         * @param {Array<string>} [externalContentOrganizationCopySource] 
         * @param {string} [userNameOrFilter] 
         * @param {string} [todoOrFilter] 
         * @param {string} [orFilter] 
         * @param {string} [creatorNameOrFilter] 
         * @param {string} [isNewestVersion] 
         * @param {string} [taskSetForTaskFilter] 
         * @param {string} [tagModeFilter] 
         * @param {string} [taskTodoAssignedGroupFilter] 
         * @param {string} [orderTitle] 
         * @param {string} [orderTaskSetTitle] 
         * @param {string} [orderCreatorUsername] 
         * @param {string} [orderEquipmentMaintenancesLastRun] 
         * @param {boolean} [taskTodosArchived] 
         * @param {boolean} [existsTaskTodos] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskCollection(page?: number, itemsPerPage?: number, pagination?: boolean, id?: number, id?: Array<number>, title?: string, lifecycle?: string, lifecycle?: Array<string>, taskSet?: string, taskSet?: Array<string>, taskSetTitle?: string, taskSetOrganization?: string, taskSetOrganization?: Array<string>, appTags?: string, appTags?: Array<string>, appTagsContext?: string, appTagsContext?: Array<string>, appTagsTitle?: string, appTagsTitle?: Array<string>, groupTaskTodos?: string, groupTaskTodos?: Array<string>, originalTask?: string, originalTask?: Array<string>, externalContents?: string, externalContents?: Array<string>, externalContentOrganizations?: string, externalContentOrganizations?: Array<string>, taskTodosUserOrganizations?: string, taskTodosUserOrganizations?: Array<string>, taskTodosTaskTodoInfoStatus?: string, taskTodosTaskTodoInfoStatus?: Array<string>, mls1Id?: number, mls1Id?: Array<number>, taskStepsConnectedForms?: string, taskStepsConnectedForms?: Array<string>, copySource?: string, copySource?: Array<string>, externalContentOrganizationCopySource?: string, externalContentOrganizationCopySource?: Array<string>, userNameOrFilter?: string, todoOrFilter?: string, orFilter?: string, creatorNameOrFilter?: string, isNewestVersion?: string, taskSetForTaskFilter?: string, tagModeFilter?: string, taskTodoAssignedGroupFilter?: string, orderTitle?: string, orderTaskSetTitle?: string, orderCreatorUsername?: string, orderEquipmentMaintenancesLastRun?: string, taskTodosArchived?: boolean, existsTaskTodos?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20072>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).getTaskCollection(page, itemsPerPage, pagination, id, id, title, lifecycle, lifecycle, taskSet, taskSet, taskSetTitle, taskSetOrganization, taskSetOrganization, appTags, appTags, appTagsContext, appTagsContext, appTagsTitle, appTagsTitle, groupTaskTodos, groupTaskTodos, originalTask, originalTask, externalContents, externalContents, externalContentOrganizations, externalContentOrganizations, taskTodosUserOrganizations, taskTodosUserOrganizations, taskTodosTaskTodoInfoStatus, taskTodosTaskTodoInfoStatus, mls1Id, mls1Id, taskStepsConnectedForms, taskStepsConnectedForms, copySource, copySource, externalContentOrganizationCopySource, externalContentOrganizationCopySource, userNameOrFilter, todoOrFilter, orFilter, creatorNameOrFilter, isNewestVersion, taskSetForTaskFilter, tagModeFilter, taskTodoAssignedGroupFilter, orderTitle, orderTaskSetTitle, orderCreatorUsername, orderEquipmentMaintenancesLastRun, taskTodosArchived, existsTaskTodos, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a Task resource.
         * @summary Retrieves a Task resource.
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskItem(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TaskJsonldTaskItemRead>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).getTaskItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a Task resource.
         * @summary Creates a Task resource.
         * @param {TaskJsonldTaskWrite} body The new Task resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTaskCollection(body: TaskJsonldTaskWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TaskJsonld>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).postTaskCollection(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a Task resource.
         * @summary Creates a Task resource.
         * @param {TaskJsonldTaskWrite} body The new Task resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTaskCollection(body: TaskJsonldTaskWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TaskJsonld>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).postTaskCollection(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCopyFromExternalContentTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TaskJsonld>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).putCopyFromExternalContentTaskItem(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCopyFromExternalContentTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TaskJsonld>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).putCopyFromExternalContentTaskItem(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCopyTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TaskJsonld>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).putCopyTaskItem(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCopyTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TaskJsonld>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).putCopyTaskItem(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGenerateNextVersionTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TaskJsonld>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).putGenerateNextVersionTaskItem(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGenerateNextVersionTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TaskJsonld>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).putGenerateNextVersionTaskItem(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TaskJsonld>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).putTaskItem(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TaskJsonld>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).putTaskItem(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Removes the Task resource.
         * @summary Removes the Task resource.
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskItem(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return TaskApiFp(configuration).deleteTaskItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Task resources.
         * @summary Retrieves the collection of Task resources.
         * @param {number} [page] The collection page number
         * @param {number} [itemsPerPage] The number of items per page
         * @param {boolean} [pagination] Enable or disable pagination
         * @param {number} [id] 
         * @param {Array<number>} [id] 
         * @param {string} [title] 
         * @param {string} [lifecycle] 
         * @param {Array<string>} [lifecycle] 
         * @param {string} [taskSet] 
         * @param {Array<string>} [taskSet] 
         * @param {string} [taskSetTitle] 
         * @param {string} [taskSetOrganization] 
         * @param {Array<string>} [taskSetOrganization] 
         * @param {string} [appTags] 
         * @param {Array<string>} [appTags] 
         * @param {string} [appTagsContext] 
         * @param {Array<string>} [appTagsContext] 
         * @param {string} [appTagsTitle] 
         * @param {Array<string>} [appTagsTitle] 
         * @param {string} [groupTaskTodos] 
         * @param {Array<string>} [groupTaskTodos] 
         * @param {string} [originalTask] 
         * @param {Array<string>} [originalTask] 
         * @param {string} [externalContents] 
         * @param {Array<string>} [externalContents] 
         * @param {string} [externalContentOrganizations] 
         * @param {Array<string>} [externalContentOrganizations] 
         * @param {string} [taskTodosUserOrganizations] 
         * @param {Array<string>} [taskTodosUserOrganizations] 
         * @param {string} [taskTodosTaskTodoInfoStatus] 
         * @param {Array<string>} [taskTodosTaskTodoInfoStatus] 
         * @param {number} [mls1Id] 
         * @param {Array<number>} [mls1Id] 
         * @param {string} [taskStepsConnectedForms] 
         * @param {Array<string>} [taskStepsConnectedForms] 
         * @param {string} [copySource] 
         * @param {Array<string>} [copySource] 
         * @param {string} [externalContentOrganizationCopySource] 
         * @param {Array<string>} [externalContentOrganizationCopySource] 
         * @param {string} [userNameOrFilter] 
         * @param {string} [todoOrFilter] 
         * @param {string} [orFilter] 
         * @param {string} [creatorNameOrFilter] 
         * @param {string} [isNewestVersion] 
         * @param {string} [taskSetForTaskFilter] 
         * @param {string} [tagModeFilter] 
         * @param {string} [taskTodoAssignedGroupFilter] 
         * @param {string} [orderTitle] 
         * @param {string} [orderTaskSetTitle] 
         * @param {string} [orderCreatorUsername] 
         * @param {string} [orderEquipmentMaintenancesLastRun] 
         * @param {boolean} [taskTodosArchived] 
         * @param {boolean} [existsTaskTodos] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskCollection(page?: number, itemsPerPage?: number, pagination?: boolean, id?: number, id?: Array<number>, title?: string, lifecycle?: string, lifecycle?: Array<string>, taskSet?: string, taskSet?: Array<string>, taskSetTitle?: string, taskSetOrganization?: string, taskSetOrganization?: Array<string>, appTags?: string, appTags?: Array<string>, appTagsContext?: string, appTagsContext?: Array<string>, appTagsTitle?: string, appTagsTitle?: Array<string>, groupTaskTodos?: string, groupTaskTodos?: Array<string>, originalTask?: string, originalTask?: Array<string>, externalContents?: string, externalContents?: Array<string>, externalContentOrganizations?: string, externalContentOrganizations?: Array<string>, taskTodosUserOrganizations?: string, taskTodosUserOrganizations?: Array<string>, taskTodosTaskTodoInfoStatus?: string, taskTodosTaskTodoInfoStatus?: Array<string>, mls1Id?: number, mls1Id?: Array<number>, taskStepsConnectedForms?: string, taskStepsConnectedForms?: Array<string>, copySource?: string, copySource?: Array<string>, externalContentOrganizationCopySource?: string, externalContentOrganizationCopySource?: Array<string>, userNameOrFilter?: string, todoOrFilter?: string, orFilter?: string, creatorNameOrFilter?: string, isNewestVersion?: string, taskSetForTaskFilter?: string, tagModeFilter?: string, taskTodoAssignedGroupFilter?: string, orderTitle?: string, orderTaskSetTitle?: string, orderCreatorUsername?: string, orderEquipmentMaintenancesLastRun?: string, taskTodosArchived?: boolean, existsTaskTodos?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20072>> {
            return TaskApiFp(configuration).getTaskCollection(page, itemsPerPage, pagination, id, id, title, lifecycle, lifecycle, taskSet, taskSet, taskSetTitle, taskSetOrganization, taskSetOrganization, appTags, appTags, appTagsContext, appTagsContext, appTagsTitle, appTagsTitle, groupTaskTodos, groupTaskTodos, originalTask, originalTask, externalContents, externalContents, externalContentOrganizations, externalContentOrganizations, taskTodosUserOrganizations, taskTodosUserOrganizations, taskTodosTaskTodoInfoStatus, taskTodosTaskTodoInfoStatus, mls1Id, mls1Id, taskStepsConnectedForms, taskStepsConnectedForms, copySource, copySource, externalContentOrganizationCopySource, externalContentOrganizationCopySource, userNameOrFilter, todoOrFilter, orFilter, creatorNameOrFilter, isNewestVersion, taskSetForTaskFilter, tagModeFilter, taskTodoAssignedGroupFilter, orderTitle, orderTaskSetTitle, orderCreatorUsername, orderEquipmentMaintenancesLastRun, taskTodosArchived, existsTaskTodos, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Task resource.
         * @summary Retrieves a Task resource.
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskItem(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<TaskJsonldTaskItemRead>> {
            return TaskApiFp(configuration).getTaskItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Task resource.
         * @summary Creates a Task resource.
         * @param {TaskJsonldTaskWrite} body The new Task resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTaskCollection(body: TaskJsonldTaskWrite, options?: AxiosRequestConfig): Promise<AxiosResponse<TaskJsonld>> {
            return TaskApiFp(configuration).postTaskCollection(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Task resource.
         * @summary Creates a Task resource.
         * @param {TaskJsonldTaskWrite} body The new Task resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTaskCollection(body: TaskJsonldTaskWrite, options?: AxiosRequestConfig): Promise<AxiosResponse<TaskJsonld>> {
            return TaskApiFp(configuration).postTaskCollection(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCopyFromExternalContentTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<TaskJsonld>> {
            return TaskApiFp(configuration).putCopyFromExternalContentTaskItem(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCopyFromExternalContentTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<TaskJsonld>> {
            return TaskApiFp(configuration).putCopyFromExternalContentTaskItem(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCopyTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<TaskJsonld>> {
            return TaskApiFp(configuration).putCopyTaskItem(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCopyTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<TaskJsonld>> {
            return TaskApiFp(configuration).putCopyTaskItem(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGenerateNextVersionTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<TaskJsonld>> {
            return TaskApiFp(configuration).putGenerateNextVersionTaskItem(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGenerateNextVersionTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<TaskJsonld>> {
            return TaskApiFp(configuration).putGenerateNextVersionTaskItem(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<TaskJsonld>> {
            return TaskApiFp(configuration).putTaskItem(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the Task resource.
         * @summary Replaces the Task resource.
         * @param {TaskJsonldTaskItemWrite} body The updated Task resource
         * @param {string} id Resource identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<TaskJsonld>> {
            return TaskApiFp(configuration).putTaskItem(body, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * Removes the Task resource.
     * @summary Removes the Task resource.
     * @param {string} id Resource identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async deleteTaskItem(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return TaskApiFp(this.configuration).deleteTaskItem(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the collection of Task resources.
     * @summary Retrieves the collection of Task resources.
     * @param {number} [page] The collection page number
     * @param {number} [itemsPerPage] The number of items per page
     * @param {boolean} [pagination] Enable or disable pagination
     * @param {number} [id] 
     * @param {Array<number>} [id] 
     * @param {string} [title] 
     * @param {string} [lifecycle] 
     * @param {Array<string>} [lifecycle] 
     * @param {string} [taskSet] 
     * @param {Array<string>} [taskSet] 
     * @param {string} [taskSetTitle] 
     * @param {string} [taskSetOrganization] 
     * @param {Array<string>} [taskSetOrganization] 
     * @param {string} [appTags] 
     * @param {Array<string>} [appTags] 
     * @param {string} [appTagsContext] 
     * @param {Array<string>} [appTagsContext] 
     * @param {string} [appTagsTitle] 
     * @param {Array<string>} [appTagsTitle] 
     * @param {string} [groupTaskTodos] 
     * @param {Array<string>} [groupTaskTodos] 
     * @param {string} [originalTask] 
     * @param {Array<string>} [originalTask] 
     * @param {string} [externalContents] 
     * @param {Array<string>} [externalContents] 
     * @param {string} [externalContentOrganizations] 
     * @param {Array<string>} [externalContentOrganizations] 
     * @param {string} [taskTodosUserOrganizations] 
     * @param {Array<string>} [taskTodosUserOrganizations] 
     * @param {string} [taskTodosTaskTodoInfoStatus] 
     * @param {Array<string>} [taskTodosTaskTodoInfoStatus] 
     * @param {number} [mls1Id] 
     * @param {Array<number>} [mls1Id] 
     * @param {string} [taskStepsConnectedForms] 
     * @param {Array<string>} [taskStepsConnectedForms] 
     * @param {string} [copySource] 
     * @param {Array<string>} [copySource] 
     * @param {string} [externalContentOrganizationCopySource] 
     * @param {Array<string>} [externalContentOrganizationCopySource] 
     * @param {string} [userNameOrFilter] 
     * @param {string} [todoOrFilter] 
     * @param {string} [orFilter] 
     * @param {string} [creatorNameOrFilter] 
     * @param {string} [isNewestVersion] 
     * @param {string} [taskSetForTaskFilter] 
     * @param {string} [tagModeFilter] 
     * @param {string} [taskTodoAssignedGroupFilter] 
     * @param {string} [orderTitle] 
     * @param {string} [orderTaskSetTitle] 
     * @param {string} [orderCreatorUsername] 
     * @param {string} [orderEquipmentMaintenancesLastRun] 
     * @param {boolean} [taskTodosArchived] 
     * @param {boolean} [existsTaskTodos] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async getTaskCollection(page?: number, itemsPerPage?: number, pagination?: boolean, id?: number, id?: Array<number>, title?: string, lifecycle?: string, lifecycle?: Array<string>, taskSet?: string, taskSet?: Array<string>, taskSetTitle?: string, taskSetOrganization?: string, taskSetOrganization?: Array<string>, appTags?: string, appTags?: Array<string>, appTagsContext?: string, appTagsContext?: Array<string>, appTagsTitle?: string, appTagsTitle?: Array<string>, groupTaskTodos?: string, groupTaskTodos?: Array<string>, originalTask?: string, originalTask?: Array<string>, externalContents?: string, externalContents?: Array<string>, externalContentOrganizations?: string, externalContentOrganizations?: Array<string>, taskTodosUserOrganizations?: string, taskTodosUserOrganizations?: Array<string>, taskTodosTaskTodoInfoStatus?: string, taskTodosTaskTodoInfoStatus?: Array<string>, mls1Id?: number, mls1Id?: Array<number>, taskStepsConnectedForms?: string, taskStepsConnectedForms?: Array<string>, copySource?: string, copySource?: Array<string>, externalContentOrganizationCopySource?: string, externalContentOrganizationCopySource?: Array<string>, userNameOrFilter?: string, todoOrFilter?: string, orFilter?: string, creatorNameOrFilter?: string, isNewestVersion?: string, taskSetForTaskFilter?: string, tagModeFilter?: string, taskTodoAssignedGroupFilter?: string, orderTitle?: string, orderTaskSetTitle?: string, orderCreatorUsername?: string, orderEquipmentMaintenancesLastRun?: string, taskTodosArchived?: boolean, existsTaskTodos?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20072>> {
        return TaskApiFp(this.configuration).getTaskCollection(page, itemsPerPage, pagination, id, id, title, lifecycle, lifecycle, taskSet, taskSet, taskSetTitle, taskSetOrganization, taskSetOrganization, appTags, appTags, appTagsContext, appTagsContext, appTagsTitle, appTagsTitle, groupTaskTodos, groupTaskTodos, originalTask, originalTask, externalContents, externalContents, externalContentOrganizations, externalContentOrganizations, taskTodosUserOrganizations, taskTodosUserOrganizations, taskTodosTaskTodoInfoStatus, taskTodosTaskTodoInfoStatus, mls1Id, mls1Id, taskStepsConnectedForms, taskStepsConnectedForms, copySource, copySource, externalContentOrganizationCopySource, externalContentOrganizationCopySource, userNameOrFilter, todoOrFilter, orFilter, creatorNameOrFilter, isNewestVersion, taskSetForTaskFilter, tagModeFilter, taskTodoAssignedGroupFilter, orderTitle, orderTaskSetTitle, orderCreatorUsername, orderEquipmentMaintenancesLastRun, taskTodosArchived, existsTaskTodos, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a Task resource.
     * @summary Retrieves a Task resource.
     * @param {string} id Resource identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async getTaskItem(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<TaskJsonldTaskItemRead>> {
        return TaskApiFp(this.configuration).getTaskItem(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a Task resource.
     * @summary Creates a Task resource.
     * @param {TaskJsonldTaskWrite} body The new Task resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async postTaskCollection(body: TaskJsonldTaskWrite, options?: AxiosRequestConfig) : Promise<AxiosResponse<TaskJsonld>> {
        return TaskApiFp(this.configuration).postTaskCollection(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Task resource.
     * @summary Creates a Task resource.
     * @param {TaskJsonldTaskWrite} body The new Task resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async postTaskCollection(body: TaskJsonldTaskWrite, options?: AxiosRequestConfig) : Promise<AxiosResponse<TaskJsonld>> {
        return TaskApiFp(this.configuration).postTaskCollection(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Replaces the Task resource.
     * @summary Replaces the Task resource.
     * @param {TaskJsonldTaskItemWrite} body The updated Task resource
     * @param {string} id Resource identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async putCopyFromExternalContentTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<TaskJsonld>> {
        return TaskApiFp(this.configuration).putCopyFromExternalContentTaskItem(body, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the Task resource.
     * @summary Replaces the Task resource.
     * @param {TaskJsonldTaskItemWrite} body The updated Task resource
     * @param {string} id Resource identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async putCopyFromExternalContentTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<TaskJsonld>> {
        return TaskApiFp(this.configuration).putCopyFromExternalContentTaskItem(body, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Replaces the Task resource.
     * @summary Replaces the Task resource.
     * @param {TaskJsonldTaskItemWrite} body The updated Task resource
     * @param {string} id Resource identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async putCopyTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<TaskJsonld>> {
        return TaskApiFp(this.configuration).putCopyTaskItem(body, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the Task resource.
     * @summary Replaces the Task resource.
     * @param {TaskJsonldTaskItemWrite} body The updated Task resource
     * @param {string} id Resource identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async putCopyTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<TaskJsonld>> {
        return TaskApiFp(this.configuration).putCopyTaskItem(body, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Replaces the Task resource.
     * @summary Replaces the Task resource.
     * @param {TaskJsonldTaskItemWrite} body The updated Task resource
     * @param {string} id Resource identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async putGenerateNextVersionTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<TaskJsonld>> {
        return TaskApiFp(this.configuration).putGenerateNextVersionTaskItem(body, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the Task resource.
     * @summary Replaces the Task resource.
     * @param {TaskJsonldTaskItemWrite} body The updated Task resource
     * @param {string} id Resource identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async putGenerateNextVersionTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<TaskJsonld>> {
        return TaskApiFp(this.configuration).putGenerateNextVersionTaskItem(body, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Replaces the Task resource.
     * @summary Replaces the Task resource.
     * @param {TaskJsonldTaskItemWrite} body The updated Task resource
     * @param {string} id Resource identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async putTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<TaskJsonld>> {
        return TaskApiFp(this.configuration).putTaskItem(body, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the Task resource.
     * @summary Replaces the Task resource.
     * @param {TaskJsonldTaskItemWrite} body The updated Task resource
     * @param {string} id Resource identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async putTaskItem(body: TaskJsonldTaskItemWrite, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<TaskJsonld>> {
        return TaskApiFp(this.configuration).putTaskItem(body, id, options).then((request) => request(this.axios, this.basePath));
    }
}
